# 并发编程
##基于进程的并发编程
#### 基于进程的并发服务器
构造并发服务器的自然方法是, 在父进程中接受客户端连接请求, 然后创建一个新的子进程来为每个新客户端提供服务.   

子进程关闭它的副本中的监听描述符, 父进程关闭它的连接描述符, 防止内存泄漏.   

![关闭连接描述符](./0.jpg)  

#### 进程的优劣
进程共享文件表, 但不共享地址空间.   

为了共享信息, 必须使用显示IPC机制.  

## 基于I/O多路复用的并发编程
....

#### 基于I/O多路复用的并发事件驱动服务器
....
#### I/O多路复用技术的优劣
- 优点:
    1. 比基于进程的设计给了程序员更多的对程序行为的控制.
    2. 运行在单一进程的上下文中, 每个逻辑流都能访问该进程的全部地址空间.
    3. 像对顺序程序那样,可以使用调试工具.
- 缺点:
    1. 编码复杂.
    2. 某个逻辑流正忙于读一个文本行, 其他逻辑流就不可能有进展.
    3. 不能充分利用多核处理器.

## 基于线程的并发编程
线程:  线程就是运行在进程上下文中的逻辑流, 线程由内核自动调用, 每个线程都有它自己的线程上下文(包括唯一的整数ID, 栈, 栈指针, 程序计数器...), 所有运行在一个进程里的线程共享这个进程的虚拟地址空间  

#### 线程执行模型
![线程执行模型](./1.jpg)  

每个进程开始生命周期时都是单一线程, 这个线程称为主线程.   

主线程执行一个慢速系统调用(read, sleep, 间隔计数器中断), 控制就会通过上下文切换传递到对等线程, 以此类推.   

线程的上下文切换比进程的上下文切换快.   

主线程和其他线程的区别仅在于它总是进程中第一个运行的线程.   

一个线程可以杀死他的任何对等线程, 或者等待它的任意对等线程终止, 每个对等线程都能读写相同的共享数据.   

#### Posix线程
[hello.c](./hello.c)   

#### 创建线程
....

#### 终止线程
一个线程是以下方式之一来终止:
- 当顶层的线程历程返回时, 线程会隐式地终止.
- 调用pthread_exit
- 某个对等线程调用exit函数, 与该进程相关的线程都终止

#### 回收已终止线程的资源
线程通过调用pthread_join函数等待其他线程终止.


#### 分离线程
线程是可结合的或者分离的.   

可结合的: 可结合的线程能够被其他线程收回和杀死.   

分离的: 一个分离的线程不能被其他线程回收或杀死.   

## 多线程程序中的共享变量
#### 线程内存模型
每个线程都有它自己独立的线程上下文, 包括线程ID, 栈, 栈指针, 程序计数器, 条件码, 通用目的的寄存器值.   

每个线程和其他线程共享整个用户虚拟地址空间.   

线程栈不对其他线程设防.   

#### 将变量映射到内存
多线程C程序中变量根据它们的存储类型被映射到虚拟内存中:  
- 全局变量: 虚拟内存的读/写区域只包含每个全局变量的一个实例, 任何线程都可以引用.
- 本地自动变量: 本地自动变量就是定义在函数内, 但没有static属性的变量, 在运行时, 每个线程的栈都包含它自己的所有本地自动变量的实例(可通过指针访问)
- 本地静态变量: 定义在函数内部, 并且有static属性的变量, 和全局变量一样, 虚拟内存中只包含一个实例., 每个**对等**线程都读写这个实例

#### 共享变量
当且仅当它的一个实例被一个以上的线程引用.   

