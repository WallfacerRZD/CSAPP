- ## 摩尔定律:当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。

- ## 汇编代码的主要特点是它用可读性更好的文本格式表示机器代码的二进制格式.

- ## 机器代码简单地将内存看成一个很大的,按字节寻址的数组

- ## C语言中的数组和结构,在机器代码中用一组连续的字节来表示,不区分有符号或无符号整数, 不区分各类型的指针, 不区分指针和整数

- ## 程序内存用虚拟地址来寻址, 在任意给定的时刻只有有限的一部分虚拟地址被认为是合法的.虚拟地址空间由操作系统负责管理


- ## 汇编代码格式: ATT和intel

- ## 寄存器
> - 8086有8个16位寄存器 %ax-%bp
> - 扩展到IA32(Intel Architecture 32bit)架构时, 这些寄存器也扩展到32位, 标号%eax-%ebp
> - 扩展到x86-64后, 这些寄存器扩展到64位, 标号%rax-%rbp此外还增加8个寄存器, 标号%r8-%r15;所有16个寄存器的地位部分都可以作为字节, 字, 双字, 和四字数字访问.

- ## 分支

### 用条件控制来实现条件分支

c语言中if-else语句通用形式模板如下:
```
if (test-expre){
    then-statement
}
else{
    else-statement
}
```
编译器通常会使用下面这种形式:
```
t = test-expre;
if (!t)
    goto false;
then-statement
goto done;
false:
    else-statment
done:
```
汇编器为then-statement和else-statement产生各自的代码块.插入条件和无条件分支,以保证能执行正确的代码块

### 用条件传送来实现条件分支
> - 编译器会计算两个表达式的值, 最后通过条件传送(cmove等指令)来把表达式的值传送给寄存器.
> - 优点是契合现代cpu流水线,避免分支预测错误造成的性能处罚
> - 缺点是如果两个表达式需要大量计算,会做大量不必要的计算.此外,如果两个表达式都计算可能会出现空指针的异常

### 编译器不具有足够的信息来做出可靠的决定使用(条件控制还是条件传送)

- ## 循环
#### do-while循环
通常会翻译为:
```
loop:
 body-statement
 t = test-expr;
 if (t)
    goto loop;
```

#### while循环
翻译方法
1. jump to middle(gcc -Og优化)
```
goto test;
loop:
    body-statement
test:
    t = test-expr;
    if (t)
        goto loop;
```
2. guarded-do(gcc -O1优化)
```
t = test-expr;
if(!t)
    goto done;
do
    body-statement
    while(test-expr)
done:
```

#### for循环
C语言标准说明下面两种代码行为一样
```
for (init-expr; test-expr; update-expre) {
    body-statement
}
```

```
init-expr
while (test-expre) {
    body-statement
    update-expr;
}

```
与for循环等价的while循环的翻译取决于优化等级(见while循环)

- ## switch语句
switch语句可以根据一个**整数**索引值进行多重分支.gcc使用跳表实现.优点是执行switch语句的时间与开关的情况的数量无关.

- ## 过程
### 运行时栈
C语言过程调用机制的一个关键特性在于使用了栈数据结构提供的先进后出的内存管理原则.

当x86-64过程需要的存储空间超出寄存器能够存放的大小时就会在栈上分配空间这个部分称为过程的栈帧

当所有的局部变量都可以保存在寄存器中, 而且该函数不会调用任何其他函数(叶子过程)时,就可以不需要栈帧

### 转移控制
call指令:将返回地址压栈,修改PC
ret指令:将返回地址弹栈, 修改PC

### 参数传递
当过程P调用过程Q时, P的代码必须首先把参数复制到适当的寄存器中.x86-64中可以通过寄存器最多传递6个整型参数,超出的部分通过栈传递(由P分配栈空间从右往左压栈(向栈空间写值??))

一下情况数据必须在内存中:
> 1. 寄存器不足够存放所有本地数据
> 2. 对一个局部变量使用地址运算符'&'
> 3. 局部变量是数组或结构

根据惯例一些寄存器被划分为调用者保存寄存器.当过程P调用过程Q时,Q必须保存这些寄存器的值,保证它们的值在Q返回到P时与Q被调用时是一样的.(根本不动它或者把它压入栈中)


leave指令(恢复父过程的栈帧):
> movq %rbp, %rsp
> popq %rbp

- ## 数组分配和访问
>假设有int数组声明E[i], E的地址在%rdx中, i在%rcx中

指令`movl (%rdx, %rcx, 4), %eax`会访问E[i]的值
伸缩因子1, 2, 4, 8覆盖了所有基本简单数据类型

### 指针运算
`A[i]` 与 `*(A + i)`等价

### 变长数组
ISO C99 允许数组的维度是表达式.

- ## 异质的数据结构

### 结构
指向结构的指针是结构第一个字节的地址,结构的所有组成部分都存放在一段连续的内存中, 可以计算偏移量来访问所有字段

### 联合
联合用不同的字段来引用相同的内存块, 一个联合的总大小等于它最大字段的大小

### 数据对齐
K个字节大小的数据,其起始地址需为K的倍数.(提高CPU读取数据的速度)
编译器会在未对齐的结构体中插入一些空间来满足数据对齐规则
[参考博客](http://blog.csdn.net/xiaof_90/article/details/51548012)




