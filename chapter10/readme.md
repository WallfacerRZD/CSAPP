# 系统级I/O
## Unix I/O
所有的I/O设备(网络, 磁盘, 终端)都被模型化为文件, 而所有的输入和输出都被当做相应文件的读和写来执行.   

- 打开文件: 应用程序通过要求内核打开相应的文件, 来宣告它想要访问一个I/O设备.内核返回一个小的非负整数, 叫做文件描述符.
- Linux shell 创建的每个进程开始时都有三个打开的文件. 标准输入, 标准输出, 标准错误.
- 改变当前的文件位置: 内核保持着一个文件位置k初始为0, 是从文件开头起始的字节偏移量. 应用程序通过执行seek操作, 显示设置文件的当前位置k.
- 读文件: 一个读操作就是从文件复制n>0个字节到内存, 从当前文件位置k开始, 然后将k += n.给定一个大小为m字节的文件, 当k>=m时执行读操作会触发EOF的条件.应用程序能检测到这个条件, 在文件结尾并没有明确的"EOF符号"
- 写文件: 从内存复制n>0个字节到一个文件, 从当前文件位置k开始, 然后更新k.
- 关闭文件: 内核释放文件打开时创建的数据结构, 并将文件描述符恢复到可用的描述符池中.无论一个进程因为何种原因终止时, 内核都会关闭所有打开的文件并释放它们的内存资源.

## 文件
Linux文件类型: 
- 普通文件: 包含任意数据.对内核而言, 文本文件和二进制文件没有区别.
- 目录: 包含一组链接的文件, 其中每个链接都将一个文件名映射到一个文件. 这个文件可能是另一个目录
- 套接字(socket): 用来与另一个进程进行跨网络通信的文件
- 命名通道, 符号链接, 字符, 块设备.....

####打开和关闭文件
进程通过调用open函数来打开一个已存在的文件或者创建一个新文件的.open函数将filename转换为一个文件描述符.
`int open(char *filename, int flags, mode_t mode)`  

进程通过调用close函数关闭一个打开的文件, 关闭一个已关闭的描述符会出错:  
`int close(int fd)`  

应用程序通过调用read和write函数来执行输入和输出:  
```
ssize_t read(int fd, void *buf, size_t n);

ssize_t write(int fd, const void *buf, size_t n);
```   

在某些情况下, read和write传送的字节比应用程序要求的要少:  
- 读时遇到EOF.
- 从终端读文本行.
- 读和写网络套接字.

## 用RIO包健壮地读写.

....

## 读取文件元数据
应用程序能够通过调用stat和fstat函数, 检索到关于文件的信息(元数据)  

```
int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
```

## 读取目录内容
```
DIR *opendir(const char *name);
struct dirent *readdir(DIR *dirp);
int closedir(DIR *dirp);
```

## 共享文件
内核用三个相关的数据结构来表示打开的文件:
- 描述符表: 每个进程都有它独立的描述符表, 它的表项是由进程打开的文件描述符来索引.每个打开的描述符表项指向文件表中的一个表项.
- 文件表: 打开文件的集合, 所有进程共享这张表.每个文件表的表项包括当前的文件位置, 引用计数, 以及一个指向v-node表中对应表项的指针.
- v-node表: 所有进程共享这张表, 每个表项包含stat结构中的大多数信息

子进程和父进程共享描述符表  

## I/O重定向
Linux shell提供了I/O重定向操作符
`linux> ls > foo.txt`  

可使用dup2函数重定向, 将描述符表中oldfd项复制到newfd中.

`int dup2(int oldfd, int newfd)`

## 标准I/O
C语言定义了一组高级输入输出函数, 称为标准I/O库., 为程序员提供了Unix I/O的较高级别的代替.

## I/O函数的选择.
- 只要有可能就使用标准I/O
- 不要用scanf或rio_readlineb 来读取二进制文件
- 对网络套接字的I/O使用RIO函数.


***
2018/1/30  
家



