## 异常
异常是异常控制流的一种形式, 它一部分由硬件实现, 一部分由操作系统实现.   
事件: 处理器状态变化  
处理器通过一张异常表的跳转表, 进行间接过程调用, 到一个专门设计的操作系统子程序来处理异常.  
根据引起异常的事件类型, 会发生以下情况中的一种:
1. 处理程序将控制返回给当前指令, 即当事件发生时正在执行的指令
2. 处理程序将控制返回给下一条指令
3. 处理程序终止被中断的程序

#### 硬件异常和软件异常
C++, Java以catch, throw, try语句形式提供的是应用级ECF   

#### 异常处理
系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号:
1. 由处理器的设计者分配: 如被零除, 缺页, 内存访问违例, 断点, 算术运算溢出
2. 由操作系统内核的设计者分配: 系统调用, 来自外部I/O设备的信号

处理器通过执行间接过程调用处理异常, 通过异常表的表目K转到相应的处理程序   

异常表的起始地址放在异常表基址寄存器中, 异常号是异常表中的索引  

异常调用与过程调用的不同:
1. 根据异常的类型, 异常调用的返回地址要么是当前指令(事件发生时正在执行的指令), 要么是下一条指令(如果事件不发生, 将会在当前指令后执行的指令)
2. 处理器会把一些额外的处理器状态压到栈中, 在处理程序返回时, 重新开始执行中断的程序会需要这些状态
3. 如果控制从用户程序转移到内核, 所有这些项目都被压到内核栈中, 而不是压到用户栈中.
4. 异常处理程序运行在内核模式下, 这意味着它们对所有的系统资源都有完全的访问权限.  

## 异常的类型
#### 中断
中断是来自处理器外部的I/O设备的信号的结果, 不是由任何一条专门的指令造成的, 是异步发生的.   
在当前指令完成执行之后, 处理器注意到中断引脚的电压变高了, 就从系统总线读取异常号, 然后调用适当的中断处理程序.当处理程序返回时, 将控制返回给下一条指令.   
剩下的异常类型是同步发生的.

#### 陷阱和系统调用
陷阱是有意的异常, 是执行一条指令的结果. 陷阱处理程序将控制返回到下一条指令.   
陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口, 叫做系统调用.  
- *syscall*:处理提供的一条特殊的指令, 允许用户对内核服务的访问: 如读文件, 创建一个新的进程, 加载一个新的程序, 终止当前进程.执行syscall指令会导致一个到异常处理程序的陷阱.   

从程序员的角度看系统调用和函数调用时一样的, 然而他们的实现非常不同.普通函数运行在用户模式中, 系统调用运行在内核模式中.

#### 故障
故障由错误情况引起, 它可能被故障处理程序修正   
当故障发生时, 处理器将控制转移给故障处理程序, 如果处理程序能修正这个错误情况, 它将控制返回到引起故障的指令, 从而从新执行它, 否则, 处理程序返回到内核中的abort例程, abort例程会终止引起故障的引用程序.  
#### 终止
终止时不可恢复的致命错误造成的结果, 通常是一些硬件错误, 处理程序将控制返回给一个abort例程, 该例程会终止这个应用程序

####Linux/x86-64系统中的异常
x86-64系统定义了高达256中不同的异常类型.    
0-31对应Intel架构师定义的异常  
32-255对应的是操作系统定义的中断和陷阱   
##### 1.Linux/x86-64故障和终止
1. 除法错误(异常0): Unix会选择终止程序, Linux shell会把除法报告为"浮点异常(Floating exception)"
2. 一般性保护故障(异常13): 一个程序引用了一个为定义的虚拟内存区域, 或者试图写一个只读的文本段.Linux不会恢复这类故障, Linux shell通常会把这种一般保护故障报告为"段故障(Segmentation fault)"
3. 缺页(异常14): 处理程序将适当的磁盘上的虚拟内存的一个页面映射到物理内存的一个页面, 然后重新执行这条产生故障的指令
4. 机器检测: 在导致故障的指令执行中检测到致命的硬件错误时发生的.

##### 2.Linux/x86-64系统调用
Linux系统提供几百种系统调用, C程序用syscall函数可以直接调用任何系统调用.   
标准C库提供了一组方便的包装函数将参数打包在一起, 以适当的系统调用指令陷入内核, 然后将系统调用的返回状态传递回调用程序.     
所有到Linux系统调用的参数都是通过通用寄存器传递的.

## 进程
异常是允许操作系统内核提供进程概念的基本构造块, 进程是计算机科学中最深刻, 最成功的概念之一   

上下文: 上下文是有程序正确运行所需的状态组成, 这个状态包括存放在内存中的程序的代码和数据, 它的栈, 通用目的寄存器, 函数计数器, 环境变量以及打开文件描述符的集合.   

进程的经典定义是**一个执行中程序的实例**.系统中每个程序都运行在某个进程的上下文中.  

在shell中运行应用程序时, 应用程序运行在shell创建的新进程的上下文中, 应用程序也能够创建新进程.   

进程提供给应用程序的关键抽象:
1. 一个独立的逻辑控制流: 它提供一个假象, 好像我们的程序独占地使用处理器.
2. 一个私有的地址空间: 它提供一个假象, 好像我们的程序独占地使用内存系统

#### 逻辑控制流
逻辑控制流: 程序计数器(PC)值的序列(对应程序可执行目标文件中的指令, 或者是包含在运行时动态链接到程序的共享对象中的指令)   

每个进程独立执行它的流的一部分, 然后被抢占(preempted)(暂时挂起), 然后轮到其他进程.   

#### 并发流
并发(concurrency): 一个逻辑流的执行在时间上与另一个流重叠(流X开始在流Y开始之后, 结束之前), 多个流并发地执行的一般现象称为并发   

多任务: 一个进程和其他进程轮流运行的概念称为多任务   

时间片(time slice): 一个进程运行它的控制流的一部分的每个时间段叫时间片   

多任务也叫时间分片   

并行:  并行流是并发流的的一个真子集, 两个流并发地运行在不同的处理器核或者计算机上, 那么我们称它们为并行流(parallel flow),它们并行地运行(running in parallel), 且并行地执行(parallel execution)




