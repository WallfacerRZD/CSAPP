- ## 优化编译器的能力和局限

编译器必须很小心地对程序只使用安全的优化, 对程序可能遇到的所有情况,在C语言标准提供的标准下,优化后的程序和未优化的版本有相同行为

包含函数调用的代码会使用内联函数优化. 

- ## 消除循环的低效率

将要执行多次但计算结果不变的代码移动到循环外.

减少过程调用

消除不必要的内存引用(先保存在局部变量中, 最后写入内存)

- ## 理解现代处理器

###整体操作

现代处理器可以并行执行指令, 同时呈现出一种简单的顺序执行指令的现象

当一系列操作必须按照严格的顺序执行时就会遇到**延迟界限**

分支预测:现代处理器会猜测是否选择某一分支,甚至在确定分支预测是否正确之前就开始执行这些操作.分支操作被送到EU, 不是确定分支该往哪里去,而是确定分支预测是否正确. 如果预测错误, EU会丢弃分支点之后的计算出来的结果.预测错误会导致很大的性能开销.

高速缓存:高速存储器, 存放着最近访问的指令(数据)

### 功能单元的性能

>延迟: 完成运算所需的总时间
发射时间: 两个连续的同类型运算之间需要的最小时钟周期数
容量: 能够执行该运算的功能单元的数量
最大吞吐量: 发射时间的倒数

发射时间很短是通过流水线实现的, 发射时间为1的功能单元被称为完全流水线化的.

CPU设计者必须小心地平衡功能单元的数量和他们的性能, 以获得最优的整体性能

- ## 循环展开

增加每次迭代计算的元素的数量, 减少循环的迭代次数.从两个方面改进程序的性能
>1. 减少了不直接有助于程序结果的操作数量(例如循环索引计算和条件分支)
>2. 减少了整个计算关键路径上的操作数量(一些指令可以并行)

编译器可以很容易地执行循环展开, 只要优化等级设置得足够高.

- ## 提高并行性

程序的性能是受运算单元的延迟限制的.将积累值放在一个单独的变量acc中.虽然计算acc新值的功能单元能每个时钟周期执行一个新操作, 但是在前面计算完成之前都不能计算acc的新值(受计算的关键路径限制)

### 多个积累变量

### 重新结合变换

- ## 一些限制因素

1. 寄存器溢出: 如果并行度超过了可用寄存器的数量那么编译器会诉诸溢出, 将某些临时值存放在内存中.








